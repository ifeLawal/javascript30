<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>HTML5 Canvas</title>
  <link href="/favicon-JS3.png" type="image/ico" rel="shortcut icon">
  
  <style>

    #brush-circle {
      border:1px solid black;
      width:40px;
      height:40px;
      border-radius: 50%;
      /* background-color: black; */
      position: absolute;
      display: none; /* need to trobuleshoot the brush flickering */
    }

    canvas {
      border: 1px solid red;
    }

    #controls {
      display: flex;
      justify-content: center;
      margin: 10px 0px;
      gap: 30px;
    }

    #click-message {
      font-family: "Helvetica neue";
      font-size: -webkit-xxx-large;
      position: absolute;
      color: gray;
      top: 40%;
      text-align: center;
    }

    html, body {
     margin: 0;
    }
    html, body {
      margin: 0;
    }

</style>

</head>
<body>
  <div id="controls">
    <div id="brush-circle"></div>
    <button id="clr-canvas">Clear</button>
    <div id="click-message">Click and drag <br>to draw</div>
  </div>
<canvas id="draw" width="800" height="800"></canvas>
<script>
  let canvas = document.querySelector("#draw");
  let ctx = canvas.getContext('2d');
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight-100;
  ctx.lineJoin = "round";
  ctx.lineCap = "round";
  ctx.strokeStyle = "#BADA55";
  ctx.globalCompositeOperation = "multiply";
  

  let lastX = 0;
  let lastY = 0;
  let hue = 0;
  let direction = true;

  let isDrawing = false;

  function draw(e) {
    if(isDrawing) {
      ctx.strokeStyle = `hsl(${hue}, 100%, 50%)`;
      console.log("Still moving on canvas");
      // ctx.lineWidth = hue;

      ctx.beginPath();
      ctx.moveTo(lastX, lastY);
      ctx.lineTo(e.offsetX, e.offsetY);
      ctx.stroke();

      [lastX, lastY] = [e.offsetX, e.offsetY];

      hue = hue % 360 + 1;

      if(ctx.lineWidth >= 100 || ctx.lineWidth <= 1) {
        direction = !direction;
      }
      if(direction) {
        ctx.lineWidth++;
      } else {
        ctx.lineWidth--;
      }
    }
    
  }

  canvas.addEventListener('mousedown', (e) => {
    isDrawing = true;
    lastX = e.offsetX;
    lastY = e.offsetY;
    hue = 0;
    clickHere.style.display = "none";
  });

  canvas.addEventListener("mousemove", draw);

  canvas.addEventListener('mouseup', () => isDrawing = false);
  canvas.addEventListener('mouseout', () => isDrawing = false);

  brushCircle = document.querySelector("#brush-circle");
  clearCanvas = document.querySelector("#clr-canvas");


  function wipeCanvas() {
    ctx.clearRect(0,0, canvas.width, canvas.height);
  }

  clearCanvas.addEventListener("click", wipeCanvas)

  const addStylesOnElement = function(elem, styles) {
    Object.assign(elem.style, styles)
  }

  brushCircle.addEventListener("mousedown", function(e) {
    if(e.offsetX > 0 && e.offsetY > 0) {
      isDrawing = true;
    }
  })

  let clickHere = document.querySelector("#click-message");

  // need to trouble shoot this brush addition

  clickHere.addEventListener("mouseover", function(e) {
    clickHere.style.display = "none";
  })

  clickHere.addEventListener("mouseout", draw)

  function followMouse(e) {
    
    
    // addStylesOnElement(brushCircle,
    //   {top:`${e.offsetY + brushCircle.offsetHeight/2}px`,
    //   left:`${e.offsetX - brushCircle.offsetWidth/2}px`});
    console.log(brushCircle.style.top);
    
    // brushCircle.style.setProperty("top", `${e.offsetY + brushCircle.offsetHeight/2}px`);
    
    brushCircle.style.top = `${e.offsetY + brushCircle.offsetHeight/2}px`;
    brushCircle.style.left = `${e.offsetX - brushCircle.offsetWidth/2}px`;
  }

  // window.addEventListener("mousemove", followMouse);
  
</script>


</body>
</html>